Microsoft connected systems

So, what is a connected system anyway? This is a term that Microsoft likes to use quite a bit today in their marketing material, so it would probably do us some good to define what it actually means. Well, a connected system is really just an application that happens to be distributed across multiple computer nodes. Here we have an app, and this app happens to be deployed across three different machines. Each machine runs part of the application logic, and all three of these machines work together to perform the overall business functionality. Now, this implies that these machines will have some way to communicate with one another, meaning that they'll pass information back and forth across the wire using some network protocol. So this is the essence of what we call a connected system, an application that's deployed across multiple machines, with a strong emphasis on the communication protocols. In the past, we've often referred to these types of applications as distributed applications. Connected systems happens to be the new label for these things in the Microsoft landscape. Alright, now let's talk about how we can build connected systems on Windows. There are actually quite a few ways to build connected systems on Windows. Microsoft has shipped numerous communication frameworks over the years for doing this. I'm guessing that most of you will probably have experience with at least one, if not all of the frameworks we're about to discuss. Back in the day, we had things like DCOM, and COM+, and even when they shipped .NET 1.0 they released a wrapper for those things called Enterprise Services. This gave us a very component-oriented approach for building connected systems, very RPC-based in nature, where you could take your COM components and deploy them around the network, and then invoke them remotely. One of the key characteristics of this technology was distributed transactions, where you could have a logical transaction span the work being done by multiple COM components throughout the network, which turned out to be very compelling in a lot of scenarios. Now, in order to take advantage of this technology, it did require you to have the DCOM infrastructure available on every node that would take part in that style of communication. With the release of .NET, they also introduced a brand new distributed object technology known as .NET Remoting. Very similar to DCOM in a lot of ways. It was also very component-oriented, and RPC in style, but it was a solution for managed code, meaning that your components would execute completely in a managed environment within the .NET CLR. As a result, .NET Remoting turned out to be very simple, and highly extensible, but it still did depend on a key piece of infrastructure, in this case, the .NET CLR. And then there's our good old friend MSMQ. Unlike the other two frameworks, which are very focused on components and RPC, MSMQ is purely focused on messaging. Meaning, it allows you to take a message and transmit it between two nodes in a connected system in an asynchronous durable and reliable fashion. It has nothing to do with components, or method calls. However, it does still require a key piece of infrastructure; that of MSMQ. If you're going to use MSMQ throughout your system, you will have to have the MSMQ infrastructure installed on every machine that will participate in that style of communication. So here we have three frameworks, all focused on communication, and they each come with some key features, and characteristics that we may want to employ in our connected systems. In fact, it's often the case where we may want to employ all three of these frameworks at the same time. Well the problem with that is that each of these frameworks comes with a unique programming model, meaning the way I write the code for one framework is going to be very different from how I write it for another. This requires your developers to become familiar with the intricacies of numerous programming models in order to accomplish what are essentially similar goals. The other problem with these traditional Microsoft frameworks is that they each restrict you to Windows everywhere throughout your connected system. Each framework depends on key infrastructure, which, for all practical purposes, is only available on Windows today, and in today's growing connected world, this restriction alone turns out to be quite problematic indeed.

The move towards services

Today, more than ever before, companies demand widespread technology freedom, and interoperability throughout their connected systems. Take for example this application scenario, where we have multiple nodes, each of which is running a different platform, and is hosting code written using a different programming framework. The challenge here is interoperability. How do I connect all of these different nodes into one logical connected system? We know we can't use one of those Microsoft communications frameworks that we talked about on the previous slide, because they each require Windows everywhere, and that's not the case here. So how do I go about accomplishing this? Well today, we can accomplish this through what are called services. A service is simply a unit of functionality that you can expose to the outside world via messaging. So we could implement services on each of these nodes, and expose the functionality of each service to the rest of this connected system through messaging. Now the way we accomplish interoperability is by implementing that messaging using standard protocols, and message formats. For example, one of the most common transport choices is HTTP, because of its widespread ubiquity throughout the web today. Pretty much every platform has built-in support for this popular protocol. And one of the most common message format choices is XML, either a custom XML dialect of your choosing, or a standard XML dialect that has well-defined semantic meaning, like RSS, or SOAP. The bottom line is, as long as your services communicate using standard protocols and message formats, you will be able to achieve your interoperability requirements. And thanks to this focus on messaging, you will also achieve a more loosely coupled architecture. These general concepts first hit the scene in the late 1990s, along with the advent of web services, and since that humble beginning, a great deal of energy has been invested throughout the industry in this line of service-oriented thinking. And now today, there are two primary philosophies that one can adopt when designing service-oriented solutions.

Service design philosophies

The first is design philosophy centers on the ideas of SOAP, and the various WS-* specifications. This general approach has really enjoyed the limelight for several years now, so it's probably something you're already somewhat familiar with. Another design philosophy, which has been gaining traction in recent years, centers on the idea of REST, or Representational State Transfer. This design philosophy is fundamentally different than SOAP, as we'll discuss over the next few slides. Each of these philosophies comes with its own pros and cons, so it's important to understand the tradeoffs between them. Although you'll surely witness some heated debates about which one of these design philosophies is better than the other, it's important to remember that both are useful within the context of your connected systems architectures. In some cases, it might make more sense to use the SOAP approach, whereas in others, it might make more sense to use a more RESTful model. Today, the SOAP approach is probably most commonly used within the context of the enterprise, where you have a more controlled environment to take advantage of the various WS-* protocols. REST, on the other hand, is probably more commonly used in public-facing web service scenarios, where you might have the requirement for a high degree of scalability. Now, these are just general rules of thumb, and not hard fast rules to go by. Now, before continuing, let's discuss each of these design philosophies in a bit more detail.

SOAP-based services

SOAP and WS-* based services build on a great deal of work that's been happening throughout the industry to implement a completely new protocol stack for services. One of the primary design goals for this new protocol stack was that of transport neutrality, meaning that any additional features, or capabilities that we want to implement for our services, should be possible to implement in a transport neutral way. And we'll accomplish that in this protocol stack by using an XML-based messaging layer. Now, this is where SOAP comes into the picture. SOAP is a particular XML vocabulary for packaging up messages that we need to transmit to our services. Let me bring up Notepad now to illustrate what a SOAP message looks like. The SOAP message always contains a root Envelope element from the SOAP namespace. I'm just going to type in ... for the SOAP namespace identifier for now just because I don't want to type it all in. Now, a SOAP Envelope contains two other elements. It contains a Header element, as well as a Body element. The SOAP Body is where you'll actually place your Payload element. So if your service is dealing with invoices, this is where your Invoice would go. (Typing) Now the SOAP Header section up here is where it gets interesting. This is where you can place additional XML-based headers that have semantic meaning around different types of capabilities. For example, this is where I can implement security, RM, and transaction capabilities. The various WS-* protocols are implemented as SOAP Headers, and those Headers would go right here. So this gives me a mechanism for implementing those types of security, RM, and transaction features, completely in XML, within the XML SOAP message. And that allows me to take advantage of those behaviors over any transport that I choose to use. Now, jumping back to the slides, that's where these various WS-* specifications fit into the picture. They're simply standard SOAP-based headers that revolve around security reliable messaging and transaction capabilities. Now, if you happen to be using any of these advanced features, you'll also need to provide your consumers with metadata that conveys to them the capabilities and requirements of your services. This gives us a complete protocol stack for implementing a wide variety of advanced services. The vendors usually implement this protocol stack within the context of an RPC-based toolkit, meaning that you would write service contracts through method signatures. Each method signature defines a service operation that you want to expose on the service. This makes the code you end up writing feel an awful lot like the code you used to write back in the days of COM+, only this time the functionality, and capabilities will be available to you in a completely interoperable fashion, even at these more advanced levels of service functionality.

RESTful services

RESTful services are fundamentally different than SOAP-based services, because they don't attempt to achieve transport neutrality. In fact, RESTful services typically embrace HTTP as the only transport used throughout the system. The reason I say typically is because RESTful design doesn't say anything about which implementation technologies you use; however, in practice, HTTP is the only commonly used protocol. With REST, you model services as resources, and you give them unique identifiers in the form of URIs. And then you interact with those resources through a standard uniform interface, or service contract. In this case, it would be the methods defined by the HTTP protocol; specifically GET, POST, PUT, DELETE, and HEAD. By standardizing on a uniform interface, we can build infrastructure around the semantic meaning of each operation, and make performance, and scalability improvements when possible. This turns out to be extremely adventitious when building highly scalable web applications and services. Now, we also need to be able to represent resources using a concrete representation, a message format, such as XML, RSS, JSON, etc. So when we work with our resources, when we request them, or update them, or create them, we're going to be passing a representation of that resource at a particular point in time. Let's look at an example of what it might be like to interact with a RESTful service. So here I have a RESTful service that deals with invoices, and let's say that I want to create an invoice. Well the way I'll do that is I'll take a representation of my invoice, and I'll send a PUT message to the address where I want that resource to live. So this address that you're looking at here is the identifier for the resource that I'm about to create. So when I send that HTTP PUT message to the service at that address, we will create an invoice with the ID of 123. Later on, someone can walk up to the service and request that particular invoice by simply sending a GET request to the service at that same address, asking for invoice 123, and that consumer will then get a representation of that invoice back out, most likely in XML format. And then later on, if someone wants to delete that invoice, they can simply send a DELETE message to the service at that address, causing that particular resource to be deleted. Now, when you build services this way, the assumption is that HTTP can provide you with all the necessary features that you need around security, and scalability, and it has proven to be a very successful design pattern used throughout the web in a wide variety of web applications, and highly scalable web services.

Service-orientation and SOA

So we have these two different service design philosophies, SOAP and REST, both of which are fundamentally different from one another, but they can both still be considered service-oriented in nature. Service orientation is a more general design paradigm focused on a separation of concerns. When we talk about service orientation, we typically focus on concepts like service autonomy, and explicit boundaries, service contracts, and polices. These core design principles help us achieve what we like to call a Service Oriented Architecture, or an SOA. This is a very abstract concept, one that's been very difficult to define in concrete terms. OASIS was the first industry group to attempt this feat, and here's the definition that they provided in one of their specifications. If you read this definition, you'll see it's also very abstract in nature, and doesn't provide much in terms of concrete details. The OASIS definition essentially says two things. First that an SOA is about organizing your application capabilities into functional units that are going to be controlled by different ownership domains. And second, that you'll provide a uniform means to interact with those capabilities. Now obviously, you could accomplish those goals in a lot of different ways. So SOA again says nothing about what technology you choose to use, or even which precise service design philosophy you might want to implement, which definitely leaves room for both SOAP, and RESTful services within your service-oriented architecture. Hopefully this discussion clears up some of the confusing terminology that's used heavily throughout this space today.

Microsoft's first attempts

Now let's turn our attention to what Microsoft has provided for building these types of service-oriented solutions. Microsoft's actually shipped a few different web service frameworks in recent years. Back with .NET 1.0, they shipped what was called ASP.NET Web Services, or ASMX. This gave us a basic model for transmitting XML messages over HTTP. It provided simple support for SOAP 1.1, and SOAP 1.2, but nothing really beyond that. Shortly after the release of .NET 1.0, they began shipping what they called the Web Services Enhancements toolkit, which was basically a speedboat vehicle for introducing support for some of the WS-* protocols they were working on at the time. Through WSE, they added support for specs like WS-Security, WS-Secure Conversation, and WS-Trust, and they also introduced support for simple TCP-based services as well. Now you could use WSE either standalone, or in conjunction with ASMX to add some of those behaviors to your ASMX services. But in the end, both of these frameworks turned out to be quite limited in several ways. In the area of SOAP-based services, they didn't provide much support for the wide variety of WS-* specifications that we would hope to have. They also didn't provide much in the way of transport neutrality, or, in other words, additional protocols, additional transport protocols that we can could use to transmit our SOAP messages. They also didn't provide much in the way of building RESTful services. So they were a good first step, but they didn't really come close to achieving the full vision of either SOAP-based services, or RESTful services. The other problem with these two frameworks is they each came with a new programming model. So, if you were building a connected system that used some of those other Microsoft communication frameworks, like COM+, .NET Remoting, and MSMQ, and then you also introduced one of these web service frameworks, now you had even more programming models your developers had to deal with. The good news is, Microsoft realized that this wasn't a good situation for their connected systems developers to be in, and so they quickly started thinking about what an ideal communication framework might look like.

The ideal communication framework

When Microsoft first started thinking about what an ideal communication framework might look like, they quickly realized that one of their core design goals would be to build a unified programming model for all communication logic. They essentially wanted to take all of the best ideas from the preceding communication frameworks, and roll them into one unified model moving forward, that would allow you to address a wide variety of different communication scenarios. This was a very ambitious goal, because it would require Microsoft to provide a tremendous amount of flexibility in several key areas. First, they knew they need to provide several options around service design. They need to make it possible to implement SOAP-based services, as well as RESTful services, or perhaps services that feel a little more like the distributed objects that you used to work with in the past. They'd also have to provide numerous choices around transport protocols, as well as message formats. In some cases, I might want to use HTTP and XML for interoperability, or as in other cases I might want to use TCP and binary messages for raw performance and efficiency. And in some other cases, I might want to use HTTP and JSON to help accommodate AJAX style applications. The point is, I should be able to pick and choose which transport, and message format combination makes the most sense for a particular communication scenario. They also knew they'd have to make it easy to pick and choose from the various WS-* protocols that you might choose to use, if any. Microsoft realized that if they could provide a high degree of flexibility around the transport, message format, and messaging protocols, that you would be able to take this framework and adapt it to pretty much any communication scenario that you might face within a large connected system. But even with that high degree of flexibility, Microsoft also realized that they wouldn't be able to accommodate every scenario in V1 out of the box. So they also knew that they would have to provide significant extensibility opportunities throughout the API, by providing numerous extensibility points that would allow you to plug in your own transports, your own message formats, or even your own messaging protocols when needed, or even your own processing behaviors when the default WCF processing doesn't fit your precise needs. So after a lot of careful analysis and design, this is what Microsoft concluded that their unified communications model should look like on Windows moving forward, and the result was Windows Communication Foundation.

Introducing WCF

So WCF is the new unified communications framework for Windows moving forward. To recap, it takes all the best ideas from these existing communication frameworks we've had on Windows, and it attempts to unify them into one logical model. This essentially greatly simplifies the communications landscape on Windows, and makes WCF the default choice for connecting your applications from this point on. Now, when you're faced with a particular communication scenario, you no longer have to suffer from paralysis by analysis, thinking about all the different communication frameworks you might choose to implement that actual scenario. Now, the choice is clear. You simply use WCF to write the communication logic, and then you decide which of its many features you wish to employ. Most of the WCF functionality is found within a single assembly called System.ServiceModel.dll, which you will get once you install the .NET Framework 3.0. Now, let's return to this connected systems scenario from before, and see what it will look like by using WCF. Well we should point out at first that WCF is indeed a service-oriented programming model. So the way we'll go about implementing this connected system is by writing, and deploying what are called WCF services on each node. Now, there's just one way to write this code, so there's only one programming model your developers will have to learn, regardless of how you might choose to communicate with these services. In one case, you may decide to use a distributed object style of communication, where you use TCP-based communications, and raw binary messages for performance reasons. In another case, you may decide to use more of a SOAP style service, where you use the SOAP-based message format on the wire, and use MSMQ to transmit those messages in a secure, reliable, and asynchronous manner. And then in another scenario, you may choose to use a RESTful style, where you actually embrace HTTP as the transport mechanism, and you retrieve resources that may be represented using the RSS format. The point is, WCF supports all these different communication styles, and many more not illustrated here. So, we have just one way to write the code, but many ways to connect the dots between the services. This, in a nutshell, is the value of WCF. Okay, time to get a little more specific. When we say there's just one way to write the code, what do we really mean? Well, in WCF, we're going to write traditional .NET classes and interfaces. The classes will represent the messages that we're going to send as part of a service operation. And the interface definition defines the set of operations that we want to expose on a particular service contract. And so we'll use traditional .NET code to layout the basic structure of these things, and then we'll annotate them with some special WCF attributes. The combination of these two things basically defines the communication contracts for our WCF services. We can then go implement these contracts on a .NET class. Notice here below, I've got a class called InvoiceService that derives from our service contract, IInvoiceService, and we simply implement the method SubmitInvoice. This is where the business logic goes. Pretty much all the services that you author with WCF will follow this basic model. So that's how you write the code. Now, how about connecting the dots? Well, in WCF you do this by configuring what are called endpoints on your service. Here I've got my InvoiceService configured with three different endpoints. Each endpoint defines a different communication option for talking to the service. This first endpoint uses REST over HTTP. The second endpoint uses SOAP and WS-* over MSMQ, and it uses binary messages by default. And this third endpoint also uses SOAP and WS-*, but over TCP, and it also uses binary messages for efficiency. So we've got a single service implementation, but three wildly different communication endpoints for talking to the service, and we were able to accomplish all of this strictly through configuration. We didn't have to touch the service implementation code at all to accommodate these different options.

Demo: Writing a simple WCF service

Let me show you how to build a simple WCF service in Visual Studio 2008. Here I have an empty Solution, and I'm going to right click on it, and select Add, New Project. Then I'm going to come over here, and select the WCF project templates within the Visual C# section, and I'm going to come over here to the right, and select WCF Service Library. Then I'll come down here to this text box, and Name my project HelloWorldService. This creates for me a simple class library solution, a simple class library project that contains a few source files, and it just kind of gives me a basic implementation of a WCF service to show me how to get started. But I really don't want these guys, so I'm just going to select them, and Delete them from this project, and start from scratch. It did give me the assemblies that I needed in my References here, so you'll see System.Runtime.Serialization, this one right here, as well as System.ServiceModel. We actually needed both of those in this case to begin writing our WCF code. So it did give me that, and it also gave me an App.config file, which I'll use to configure my WCF service within the test applications that come with Visual Studio 2008. So, to actually begin working with this thing, I'm going to right click, and select Add, New Item. Then I'm going to select Class, and I'm going to come down here and type in HelloWorldService. This gives me a new class file in which I can begin writing my WCF service code. So, I'm going to come in here, and I'm going to define a class called Name. We're going to have an operation called SayHello that takes a Name as input. The Name will contain a First Name, as well as a Last Name. Now in order to make this usable within a WCF service operation, I need to annotate this class with a DataContract attribute. And notice when I type in DataContract that red underscore appears allowing me to hit Ctrl+., then I can say let's add that using statement for System.Runtime.Serialization, so that comes in. Then for each field that I wish to expose, I type in DataMember. I'll need to do this down here with Last as well. And now we have a type that I can use within my service operation. Now I'll define a public interface called IHelloWorld. And IHelloWorld's going to have a single operation that returns a string called SayHello, and this will take one of our Name objects, and we'll just call that person. Now in order to expose this as a service contract, I also need to annotate the interface with the ServiceContract attribute. Now, if I hit Ctrl+. here, that will allow me to bring in the System.ServiceModel namespace. And the other attribute I need to apply here on the method is the OperationContract attribute. So that tells WCF that this is a service-oriented contract that could be hosted within, that can be exposed through a WCF service endpoint. Now to actually implement this ServiceContract, I'll come down here to this class, which I'm going to make public, and I will simply derive it from IHelloWorld. And here I can press Ctrl+. to automatically implement that interface. And then down here within the implementation of SayHello, I will simply return string.Format, passing in Hello, First, Last, and we'll pass in person.First, person.Last. Okay, that'll be our implementation. Now notice I didn't have to annotate this implementation class with any additional attributes. All of the contractual attributes are simply inherited from the interface definition, and the class definitions that we're using in the operations. So when we say there's one way to write the code, this is essentially what we're talking about. We're talking about this programming model for adding attributes to classes and interfaces, and implementing those on a concrete surface implementation class. Now we're ready to host this service. At this point, we'd either have to write our own host application, or host this thing and deploy it inside of IIS. But there is another way. Visual Studio 2008 comes with a test WCF service host application, which will allow you to automatically host up your WCF service libraries without writing any code. And so that's the approach I'm going to use. But we still have to tell that host application what endpoints I want to expose on this service. So we'll do that over here inside of our App.config file. So, let me bring that up. Okay, here I'm going to need to update this App.config file to tell it the name of my service that I'm trying to expose. In our case, it was called HelloWorldService. And I'm also going to change the baseAddress here to something a little simpler. I'll change the baseAddress to 8080/helloworld. And then down here below is where I'll put all my endpoints. Now, they put a bunch of stuff in here that I'm not going to need for this example, so I'm simply going to remove them, and I'm going to change the contract on this first endpoint that it gave me to IHelloWorld. Then I'm going to copy this endpoint and add a few different endpoints into the mix. So the first endpoint will have a relative address of ws. So we'll have a baseAddress of localhost:8080/helloworld/ws, and that's going to use the wsHttpBinding, and my contract is IHelloWorld. If we jump back to the code just to confirm that's what our interface name was. And then the second one is going to use the basicHttpBinding. So we'll have a relative address of basic, the binding will be the basicHttpBinding, and it also exposes the IHelloWorld service contact. And finally, we'll have a TCP-based endpoint. So we'll have a relative address of tcp. I'll specify the netTcpBinding, and, actually I can't use a relative address of tcp, I'm going to use a full address specifying net.tcp as the protocol scheme, localhost:8081/helloworld. So we'll actually use a full address for the TCP endpoint. Now, with this in place, we're ready to host the service. All I need to do is save this file, and then I can go ahead and press F5 to launch the WCF service host application. You'll notice this little bubble shows up down in the system tray showing me that the WCF service host did indeed launch, and you'll see this little icon show up down here in the corner. If I double click on that, it brings up the Service Host application, and you'll notice that it thinks it's indeed hosting our HelloWorldService. It shows the service as Started, and it shows the Metadata Address where we can request metadata from this service. I didn't really mention that, but if you look at the App.config file, this service was indeed configured to expose metadata. Then it also launched this WCF Test Client application, which automatically requested the metadata from our service running in that test host, and it downloaded all of the endpoints. It actually found three endpoints that were available on that service, and this actually shows you the different endpoints that we had. And then it gives us the ability to invoke any one of these different endpoints. I can just double click on the operation, and then over here it gives me a little form to type in the information that I want to send across as part of this operation name, as part of this service operation set of, this service operation message, I should say, and then I can go ahead and press Invoke. That sends a message to our service, and hopefully we'll get a response back here that says Hello Aaron Skonnard. I can go ahead and press SayHello on a different endpoint, and now we'll invoke it using TCP. So here we'll pass in Joe Bob, and press Invoke, and this went over the TCP-based endpoint. So, there you have an example of building a simple WCF service. We wrote the code in this one C# file. In fact, let me stop the debugger, so I can show you this in full screen. There was one way to write this code, but there were many ways to talk to that code through these three different endpoint definitions that we configured on the service.

Services and endpoints

To summarize what we just saw, with WCF you write services that expose endpoints to the outside world. Your service implementation defines the actual business logic. That's the way you write the code. And the endpoints define the various communication options you want to support by the service. That's how you connect the dots. Now, services can expose multiple endpoints for consumers. You can have as many as you'd like. But you have to have at least one, otherwise your service won't be very useful because no one will be able to talk to it. So the service defines the business logic, and the endpoints define the communication options. So what exactly is an endpoint? Well, an endpoint is a piece of information that tells WCF how to build the underlying communication channels that will be used at runtime, to both send and receive messages. Each endpoint definition consists of three things; an address, a binding, and a contract. The address defines a network address for both sending, and receiving messages. In the case of a WCF service, the WCF runtime will produce a transport channel that's prepared to listen for messages at that address. And in the case of a WCF client, it'll produce a transport channel that's prepared to transmit messages to that address. The binding specifies how to send the messages. For example, it specifies what transport protocol to use, what message format, and which, if any of the WS-* protocols you want to use through that particular endpoint. The binding actually conveys quite a bit of information, and it's used quite heavily by the runtime to build all of the communication channels that will be needed at runtime to support that particular style of communication. And finally, we have the contract, which tells us what the messages must contain. This basically provides additional detail around the structuring contents of the various messages that will be used by the operations exposed through this particular endpoint. So each endpoint consists of these three things; the address, the binding, and the contract, and they provide all the information we need to either listen for messages at a particular address, or to send messages to a particular address. So services expose endpoints, while clients consume them, providing for a very symmetric model on both sides of the wire when you're using WCF to build your clients, as well as your services.

Built-in bindings

Let's just spend a few more seconds discussing this idea around bindings. A binding is essentially a recipe for how WCF will build the underlying communication channel. Now, WCF comes with a whole bunch of built-in bindings for some common communication scenarios, and I've listed those here. You can think of these as just a bunch of built-in recipes for how WCF will configure the underlying channel stacks. As you can see here, the first three bindings all use HTTP. The transport is actually implied within the binding name. The first one provides RESTful style communications, whereas the following two provide SOAP style communications. The BasicHttpBinding gives you simple SOAP support that conforms to the WS-I Basic Profile. That'll give you a high degree of interoperability with other non-Microsoft SOAP-based toolkits. Whereas the WSHttpBinding will give you access to the full range of WS-* protocols for those more advanced web services scenarios. Now, since all three of these HTTP bindings are meant for interoperability, they all use XML message formats on the wire. Now, the remaining four bindings shown in this table do not have a goal around interoperability. In fact, they actually assume that you'll be using WCF on both sides of the wire. That's why their names begin with Net, because the assumption is their going to be used for .NET-to-.NET communication. The NetTcpBinding is used for cross-machine communication over TCP, and the NetPeerTcpBinding is also used for cross-machine WCF communication, where you want peer-to-peer semantics. The NetNamedPipesBinding gives you same-machine communications in a very efficient manner. So, if your clients actually reside on the same machine as the services, or perhaps even within the same process, or app domain, that would be the binding you would want to use. And finally, we have the NetMsmqBinding, which allows us to make WCF service calls over MSMQ as a transport. All of these Net bindings use efficient binary messages on the wire, because, again, they aren't trying to accomplish interoperability, and since we know we'll have WCF on both sides, they always optimize for performance and efficiency. Now, typically you'll just be able to pick one of these bindings, the one that best fits the communication scenario you're trying to tackle. But if you run into a scenario that can't be satisfied with one of these built-in bindings, you can always write a custom binding, or a custom recipe, that specifies your exact communication requirements.

Consuming services with WCF

Up to this point we've primarily been talking about using WCF from the perspective of implementing services, but you can also use WCF to consume services out there on the network. In order to consume a service, however, you're going to need to know several things. The client will need to know where to send the message. It'll need to know how to send the message, such as what transport, and WS-* protocols to use. And it will need to know what the messages should contain. So it's going to need to basically know all the details that are made available in an endpoint; the address, the binding, and the contract. So, how do you go about building a WCF client? Well, with WCF you consume services through what are called channels, and you build channels based on endpoints. First, the client has to somehow retrieve the endpoint definitions from the service metadata. So here we have a service sitting out there on the network, and it has exposed several endpoints, and let's say that the client wants to talk to it through that middle endpoint. Well, somehow the client's going to have to walk up to this service and request the metadata, typically in the form of a WSDL definition. That metadata will come down to the client, and the client will run that metadata file through what's called a metadata import tool. That will produce a client-side version of those endpoint definitions. When using WCF on both sides of the wire, it'll essentially look just like the endpoint definitions that we used on the server side. Once the client has those local endpoint definitions, it can then construct a channel based on the endpoint of interest, and once it has constructed that channel, it can simply make method calls through that channel to transmit the appropriate messages to the service. So, as you can see, endpoints provide for some very nice symmetry across clients and services.

Demo: Writing a simple WCF client

Now, let me show you how to build a simple WCF service client that consumes the HelloWorldService we just built. So, I'll start by pressing Ctrl+F5 to launch our HelloWorld service into the WCF Service Host application, the test host that comes with Visual Studio 2008. Notice our HelloWorldService is up and running now. We can right click, and select Copy Metadata Address to grab the metadata address into our Clipboard. Now, I can return to Visual Studio and I want to build a new client that can talk to that service, so I'm going to Add a New Project, and I'm going to add a Console Application project, and I'll just call this thing Client. And then I'm ready to add a reference to our HelloWorldService. Well, one of the new features in Visual Studio 2008 is the Add Service Reference feature. So I can select that, and then Paste in the address to our metadata endpoint, and press Enter. This contacts the service, and downloads the metadata, and shows me the service contracts that are available, and the operations that are found on them. If I'm happy with that service, I can go ahead and type in a name for my service reference. In this case, I'll call it HelloWorldServiceReference, and press OK. That downloads the metadata, and generates a few things for me. It adds in all the WCF assemblies that I'll need in the Client project, and it creates this Service Reference node here, which basically is just a nice package for all the code it created, and it also adds this app.config file, which will contain all of the client side endpoint definitions for talking to that service. If you right click on the Service References, and select View in Object Browser, you can actually come over here and look at all the code that it generated for you on the client side. Notice we have the Name class with our First and Last Name fields. It also created the IHelloWorld interface with our SayHello operation, and it created a wrapper proxy class called HelloWorldClient. That'll make it really easy to invoke our service from the client side through that IHelloWorld interface. Okay, so that's what we're going to use. So, to begin writing our code, we just need to come into our source file, and first add in a namespace, a using statement for our HelloWorldServiceReference. Then I can come in here and instantiate a HelloWorldClient. Now, when I instantiate this, the thing I need to pass in here is the endpoint name that I want to use. If we jump back over here to our app.config file, and open it up, you'll see that it actually created three endpoint definitions for me on the client side, and each one represents one of the endpoints that we had configured originally on the service side. So, I just have to decide which one of these endpoints I want to use. How about we'll use the NetTcp endpoint for this example? So, here's the endpoint name. I'm going to grab that endpoint name and put it in my Clipboard, and then jump back here to the source file, and Paste that endpoint name right here into my code. So, now when it constructs this client proxy object, it'll actually build the underlying communication channel based on that endpoint definition. Then, I'll need to generate a Name object, and I'll need to fill it up with some data. We'll have the First field, let's pass in my name, along with the Last field, and then I can go ahead and call client.SayHello, and pass in the person object. Now remember, SayHello returns a string, so I could actually just print out to the Console Window the result of calling SayHello. That's what I'll do. Let me go ahead and Build this, make sure it Builds. And now we're ready to test our client. Now there's a few different ways we could test this client. We could just dropout to a Console Window, and try invoking it directly, or we could tell Visual Studio 2008 to launch it for us. I'll do the latter. So, I'm also going to add in just a little Console.ReadLine to hold this Window open after its done executing. Then I'm going to come over here to my HelloWorldService, and I'm going to right click on it, and go to Properties, and then in the Debug Window, notice here you can specify the name of the client application you want it to execute. Well the name of our client application is client.exe, and I need to specify the working directory, which is going to be Client, bin, Debug. So that's the working directory where this client.exe lives, and client.exe is the name of the application. So now, if I go ahead and Close this, I should be able to just press F5 to test both our service, and our client at the same time together. So, I'll press F5. It launches the service within the service host, and then notice it launched our Client Console application, and it printed the result of calling SayHello to our Console window. So in this demo you saw how to build a client application by walking up to a service, retrieving its metadata, and generating local endpoint definitions, and service contract definitions that you can use to build a client side WCF channel for communicating with that service.

Some common WCF questions

Now that we've finished taking a quick lap around the WCF programming model, let's conclude our discussion by answering some of these common questions that developers often ask when they're first introduced to this new technology. The first is, how far can WCF reach? In other words, how many other frameworks are there in the world that WCF can interoperate with? Well, the answer to this question is actually a function of the number of WS-* protocols you choose to use within your services. And I basically plotted the answer here on this graph. Obviously, the more WS-* protocols you use in your services, the fewer interoperable frameworks you'll find in the world, and the converse is also true if you don't use hardly any WS-* protocols. Perhaps you're doing simple SOAP, or REST, and you're not using any of them, you'll basically be able to interoperate with almost any other framework in the world today. The reason for this is because it's really difficult to implement the full range of WS-* protocols. Today, only four large vendors have been able to accomplish this successfully. You have Microsoft, IBM, Oracle. There was also BEA, but it was recently acquired by Oracle, and SAP. If you're using the full range of WS-* protocols in WCF, you're most likely only going to be able to interoperate with one of the frameworks provided by one of these other vendors. Now, again, if you don't use hardly anything in terms of the WS-* support, then it's pretty much wide open. You'll be able to interoperate with almost any other framework on the planet. The next question that people often ask is, what about all my existing communication code? Let's say I have existing investments built with ASMX, or WSE, or .NET Remoting, or COM+. What about all those things? What's my migration path forward? Well, first it's important to note that WCF does integrate on the wire with some of those key Microsoft frameworks that we discussed earlier. For example, WCF can integrate with COM+ Enterprise Services, as well as ASMX, and WSE 3.0, as well as MSMQ. So, assuming you have investments around built with one of those different communication stacks, you can plug your new WCF applications into those existing investments on the wire. You can effectively bridge between those different communication components using some of the features that WCF provides out of the box. Now, you can also fully migrate the code. If you want to take that COM+, or ASMX, or MSMQ code and port it over to WCF, that's usually pretty simple and mechanical. It's not going to require huge amounts of time and investments, unless you used a lot of low level extensibility code. And the one thing I should note about this picture is the one missing framework here, of course, is .NET Remoting. Wire-level interop with .NET Remoting is not supported by WCF. Another key question is, what does WCF run on? The answer to this is pretty simple. Basically, all of today's modern Windows platforms. WCF can run on Windows XP SP2, Windows Server 2003, Windows Vista and Longhorn, and Windows Mobile, at least a subset of WCF. And finally, the last question we need to answer is, why should I move towards WCF? Well, there're actually lots of answers to this question, but probably the most fundamental reason is that it's bound to increase your developer productivity. Thanks to WCF's unified programming model, your developers now only have to worry about a single programming model for writing all their communication logic. And that fact alone is bound to increase your developer productivity results over time. Another reason is that if you move to WCF, you will immediately increase your interoperability potential. Like we discussed, WCF is capable of doing basic web services, and all the way up to advanced SOAP and WS-* communications, giving you a wide range of communication options on the wire. WCF also provides increased flexibility. Not only in terms of the communication, like we just talked about, but also in terms of being able to plug in your own code. WCF is one of the most extensible frameworks I've ever worked with it. If you're not happy with some of the built-in functionality that comes with WCF out of the box, you can always inject your own behaviors, and communication protocols that address your precise needs. Plus, the way WCF is designed to work, you don't actually have to move everything over to WCF immediately. You can also choose to adopt WCF piecemeal, step-by-step. You may decide today that you're just going to start building some of your new services with WCF, just to get your feet wet, to get familiar with how it works, and understand the issues you're going to run in to. And, of course, thanks to its interoperability potential, and the fact that it can integrate on the wire with some of today's existing Microsoft frameworks, it's very easy to plug those new WCF services into your existing connected systems. There's no reason why you have to decide to move your entire connected system over to WCF at a single point in time. And the last, perhaps most practical reason for moving towards WCF, is that all of Microsoft's future communications work is focused here. So, if you want to benefit from all of Microsoft's future investments on the communications front, you'll really need to move over to WCF at some point in time.

Summary

And that brings us to the end of this module. To summarize, WCF provides a unified programming model with great flexibility around communications. It essentially replaces the need for all of the preceding Microsoft Windows based communications frameworks, and it does so by bringing all the key features, and capabilities from those frameworks into one unified runtime, that gives you your choice of architectural style, transport, message format, and messaging protocols. This really is the new DCOM for the next decade.
